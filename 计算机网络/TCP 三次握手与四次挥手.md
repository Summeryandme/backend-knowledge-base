# TCP 基本认识
## TCP 头部格式
TCP 头部中所包含的与建立连接相关的字段主要有以下几个

- 序列号，在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小，用来解决**网络包乱序**的问题
- 确认应答号，指下一次「期望」收到的数据的序列号，发送端收到这个确认应答之后可以认为在这个序号以前的数据都已经被正常接收，用来解决**丢包**的问题
- 控制位
   - ACK，该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外，该位必须设置为 1
   - RST，该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接
   - SYN，该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定
   - FIN，该位为 1 时，表示今后不会再有数据发送，希望断开连接，当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段
## TCP 和 UDP 可以使用同一个端口号吗
答案是**可以**

在数据链路层中，通过 MAC 地址来寻找局域网中的主机，在网络层中，通过 IP 地址来寻找网络中互连的主机和路由器，在传输层中，需要通过端口号进行寻址，来识别同一计算机中同时通信的不同应用程序，所以，传输层中端口号的作用是，区分同一个主机上不同应用程序的数据包，传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块

# TCP 连接建立

- 一开始，客户端和服务端都是`CLOSE`状态，先是服务端主动监听某个端口，处于`LISTEN`状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段，同时把`SYN`标志置为 1，接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于`SYN-SENT`状态
- 服务端收到客户端的`SYN`报文后，首先服务端也随机初始化自己的序列号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入`client_isn + 1`，接着把`SYN`和`ACK`标志设置为 1，最后把该报文发送客户端，该报文也不包含应用层数据，之后服务端处于`SYN-RCVD`状态
- 客户端收到服务端报文之后，还要像服务端回复最后一个应答报文，首先该应答报文 TCP 首部`ACK`标志位设置为 1，其次「确认应答号」字段填入`server_isn + 1`，最后把报文发送给服务端，**这次报文可以携带客户到服务端的数据**，之后客户端处于`ESTABLISHED`状态
- 服务端收到客户端的应答报文之后，也进入`ESTABLISHED`状态
## 为什么是三次握手，不是两次或者四次
常用回答：因为三次握手才能保证双方具有接收和发送的能力

TCP 连接是，用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接，所以，重要的是为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接，主要分为以下三个方面

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费
## 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢
主要有以下两个方面：

- 为了防止历史报文被下一个相同四元组的连接接受（主要原因）
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接受
# TCP 断开连接
四次挥手流程如下：

- 客户端打算关闭连接，此时会发送一个 TCP 首部`FIN`标志被置为 1 的报文，之后客户端进入`FIN_WAIT_1`的状态
- 服务端接收到该报文之后，就向客户端发送`ACK`应答报文，接着服务端进入`CLOSE_WAIT`状态
- 客户端收到服务端的`ACK`应答报文之后，进入`FIN_WAIT_2`状态
- 等待服务器处理完数据后，也向客户端发送`FIN`报文，之后服务端进入`LAST_WAIT`状态
- 客户端收到服务端的`FIN`报文之后，回一个`ACK`应答报文，之后进入`TIME_WAIT`状态
- 服务端收到`ACK`应答报文之后，就进入了`CLOSE`状态，至此服务端已经完成连接的关闭
- 客户端在经过`2MSL`一段时间之后，自动进入`CLOSE`状态，至此客户端也完成连接的关闭
## 关于 2MSL
Maximum Segment Lifetime，报文最大生存时间，之所以要等待 2MSL 时间再关闭的原因，比较合理的解释是，网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间
