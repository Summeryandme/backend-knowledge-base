**什么是垃圾？**
垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾

- 迟早会花完所有内存
- JVM 整理出的内存分配给新的对象
- 没有 GC 很难保证用户的应用程序的正常运行
# 垃圾标记阶段
对象存活判断，只有被标记死亡的对象，才会进行垃圾回收
当一个对象已经不再被任何的存活的对象继续引用时，就可以宣判为已经死亡
判断对象是否存活的方式：**引用计数算法**和**可达性分析算法**
## 引用计数

- 为每个对象保存一个整型的引用计数器属性，用于记录被引用的情况
- 只要计数器的值为0，就是垃圾

优点：

- 实现起来简单，垃圾便于辨识，判定效率高，回收没有延迟

缺点：

- 需要单独的字段存储计数器，增加了存储空间的开销
- 每次赋值都需要更新计数器，增加了时间开销
- **最严重的问题：无法处理循环引用的情况**，很致命，**导致Java的垃圾回收器中没有使用该类算法**
   - 会造成内存泄漏的问题

Python用的就是这个引用计数算法
Python如何解决循环引用？

- 手动解除，在合适的时机，解除引用关系
- 使用弱引用weakref，它是Python的标准库
## 可达性分析（根搜索算法、追踪性垃圾收集）
Java、C#
所谓“GC Roots”根集合就是一组必须活跃的引用
基本思路

- 可达性分析算法是以根对象集合（GC Roots）为起始点，按照从上到下的方式**搜索被根对象集合所连接的目标对象是否可达**
- 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链
- 只要是存活的对象，都会直接或者间接被连接到
### GC Roots包括哪些元素

- 虚拟机栈中引用的对象
- 本地方法栈内JNI（通常说的本地方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁synchronized持有的对象
- Java虚拟机内部的引用
- 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

除了以上固定的GC Roots集合以外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”的加入，共同构成完整GC Roots集合，比如：分代收集和局部回收（Partial GC）
如果要使用可达性算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行，这点不满足的话分析结果的准确性就无法保证，这也是导致GC时必须stop the world的一个重要原因

- 即使号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的
## 对象的 finalization 机制

- Java语言提供了对象终止机制来允许开发人员来自定义处理逻辑
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收对象之前，总会先调用这个对象的finalize()方法
- 永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制去调用
   - 可能导致对象复活
   - 执行时间没有保证，完全由GC线程决定，极端情况下没有执行的机会
   - 一个糟糕的finalize()会严重影响GC的性能
- 由于finalize()的存在，虚拟机中的对象一般处于三种可能的状态
   - 可触及的
   - 可复活的，对象所有的引用都被释放，但是对象可能在finalize()中复活
   - 不可触及的，对象的finalize()中没有复活，进入不可触及的状态，不可触及的对象不可能被复活，**finalize()只能够被调用一次**
- 判断一个对象是否可以被回收，至少要经历两次标记的过程
   - 如果对象到GC Roots没有引用链，则进行第一次标记
   - 进行筛选，判断此对象是否有必要执行finalize()方法
      - 如果对象没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，对象被判定为不可触及的
      - 如果对象重写了finalize()方法，且还未执行过，那么对象会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行
      - finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记，如果对象在finalize方法中与引用链的任何一个对象建立了联系，那么在第二次标记时，对象会被移除“即将回收”集合，之后，对象会再次出现没有引用存在的情况，在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次
# 垃圾清除阶段
## 标记清除（Mark-Sweep）算法

- 标记：Collector从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的Header中标记为可达对象
- 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其header中没有标记为可达对象，即将其回收

缺点：

- 效率不算高
- 在进行GC的时候，需要STW
- GC之后，内存空间不连续，产生内存碎片，需要维护一个空闲列表

何为清除：

- 所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置是否足够，足够的话直接覆盖垃圾
## 复制（copying）算法
优点：

- 没有标记和清除的过程
- 复制过去以后保证空间的连续性，不会出现碎片问题

缺点：

- 此算法的缺点也是很明显的，就是需要两倍的内存空间
- 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小

引用场景：
新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间，回收性价比高，所以现在的商业虚拟机都是用这种算法来回收新生代的
## 标记-压缩（mark - compact）算法
在老年代，垃圾比较多，用复制算法不合适

- 没有碎片，但是效率比较低
- 标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉，这样的话，当需要给新的对象分配内存的时候，jvm只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销
|  | Mark-sweep | Mark-Compact | Copying |
| --- | --- | --- | --- |
| 速度 | 中等 | 最慢 | 最快 |
| 空间开销 | 少（会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍大小（不堆积碎片） |
| 移动对象 | 否 | 是 | 是 |

## 分代收集算法
主要是根据各个年代的特点进行不同的算法
目前几乎所有的垃圾回收器都是采用分代收集算法执行垃圾回收的

- 年轻代，回收频繁，适合用于复制算法
- 老年代，对象存活率较高，复制算法不合适，一般是标记-清除或者标记-整理**混合实现**
   - Mark 阶段的开销与存活对象的数量成正比
   - Sweep 阶段的开销与所管理的区域的大小呈正相关
   - Compact 阶段的开销与存活对象的数量成正比

以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高，而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施，当内存回收不佳（碎片导致的 Concurrent Mode Failure时），将采用 Serial old 执行 Full GC 以达到对老年代内存的整理 
### 增量收集算法
为了解决 STW 时间长影响用户体验的问题，导致了增量收集算法的产生
基本思想：如果一次性处理全部的垃圾，必然造成较长时间的停顿，可以让垃圾收集线程和用户线程交替进行（并发）
### 分区算法
一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也就越长，为了更好的控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小的，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿
分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同分区 region
每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个小区间
# System.gc()的理解
默认情况下，调用 System.gc() 或者 Runtime.getRuntime().gc() 的调用，会显示触发 Full GC，同时对新生代和老年代进行回收，尝试释放对象占用的内存

- 但是**无法保证**对垃圾收集器的调用！（只是有可能！）
- 一般情况下，垃圾回收是自动进行的，无须手动触发，否则过于麻烦，如果是在做性能基准的测试，可以调一掉 
## 内存泄漏
严格来说，只有对象不会再被程序用到了，但是 GC 又无法回收它们的情况，才叫内存泄漏
但是实际情况下，有很多时候有一些不太好的实践（或者疏忽）也会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。
举例

1. 单例模式
   1. 单例的生命周期和应用程序一样长，如果在单例程序中持有对外部对象的引用的话，那么这个外部对象是不能被回收的
2. 一些提供 close() 的资源未关闭
## stop-the-world
可达性算法中枚举 gc roots 会导致所有 java 执行线程停顿

- 分析工作必须在一个能够保证一致性的快照中进行
- 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
- 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
# 垃圾回收的并行与并发
并发（Concurrent）
在同一个处理器上运行
并行（Parallel）
在多个处理器上运行
并发和并行，在讨论垃圾回收期的上下文语境中，它们可以解释如下：

- 并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
- 串行：单线程执行，
- 并发：垃圾回收线程和用户线程同时进行
# 安全点（safe-point）
程序执行并不是在所有的地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点”！
如果安全点设置的太少，会导致 GC 等待的时间太长，如果设置的太多，又会导致性能上的问题
大部分指令执行的时间都比较短，所以通常会根据“是否具有让程序长时间执行的特征”为标准来设置安全点
比如方法调用、循环跳转和异常跳转等，这些指令会比较长
### 如何确保在 GC 发生的时候，所有的线程都停顿到安全点？

- 抢先式中断：（目前已经 out）
   - 首先中断所有线程，如果还有线程不在安全点，就恢复线程，让线程跑到安全点
- 主动式中断：
   - 设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将自己挂起

安全区域：
安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 GC 都是安全的
在实际执行的时候

- 当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程
- 当线程即将离开 Safe Region 的代码时，会检查 JVM 是否完成了 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止
# Java 中几种不同的引用

- 强引用（StrongReference）：死都不会回收，内存溢出只和强引用有关系
- 软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收，如果这次回收后还是没有足够的内存，才会抛出内存溢出异常
   - 软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用
   - jdk 1.2 以后提供了SoftReference 类来实现软引用
   - SoftReference<User> softReference = new SoftReference<User> (new User(1, "abc"))
- 弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次 GC 之前，当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象
   - 发现即回收
- 虚引用（PhantomReference）：一个对象是否有虚引用的存在，**完全不会对其生存时间构成任何影响**，也无法通过虚引用来获得一个对象的实例，为一个对象设置虚引用关联的唯一目的就是在这个对象被收集器回收时收到一个系统通知
   - 虚引用必须和引用队列一起使用，虚引用在创建时必须提供一个引用队列作为参数，当垃圾回收器准备回收一个对象时，如果发现他还有虚引用，就会在回收对象之后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况
- 垃圾回收器没有在规范中进行过多的规定，可以由不同的厂商、不同的版本的 JVM 来实现
- 由于 JDK 版本处于告诉迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本
- 从不同的角度分析垃圾收集器，可以将 GC 分为不同的类型

按照线程数分

- 串行垃圾回收器
- 并行垃圾回收器

按照工作模式分

- 并发式垃圾回收器
- 独占式垃圾回收器

按照碎片处理方式分

- 压缩式
- 非压缩式

按工作的内存区间分

- 年轻代垃圾回收器
- 老年代垃圾回收器
### 评估 GC 的性能指标

- 吞吐量：运行用户代码的时间占总运行时间的比例
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间占总时间的比例
- 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：相对于应用程序的运行，收集操作发生的概率
- 内存占用：Java 堆区所占内存的大小
- 快速：一个对象从诞生到被回收所经历的时间
#### 吞吐量 vs. 暂停时间
它们是一组矛盾的指标

- 如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致 GC 需要更长的暂停时间来执行内存回收
- 相反，如果以暂停时间优先，那么只能频繁 GC，会引起年轻代内存的缩减和导致程序吞吐量下降

目前的标准是：**在最大吞吐量优先的情况下，降低停顿时间**
# 7 款经典收集器与垃圾分代之间的关系

- 新生代收集器：Serial 、ParNew、Parallel Scavenge
- 老年代收集器：Serial Old、Parallel Old、CMS
- 整堆收集器：G1

![image.png](https://cdn.nlark.com/yuque/0/2022/png/28316065/1667189971375-5027cbe5-8b48-4b5b-b874-d1ec3543de52.png#averageHue=%23dfe1dd&clientId=u4f4f76dc-c7be-4&from=paste&height=369&id=u6f45fdd6&name=image.png&originHeight=922&originWidth=1726&originalType=binary&ratio=1&rotation=0&showTitle=false&size=494861&status=done&style=none&taskId=ue0fc0323-9ffe-4762-b7e1-1ffdaadeac0&title=&width=690.4)
# Serial 回收器：串行回收
![image.png](https://cdn.nlark.com/yuque/0/2022/png/28316065/1667191100334-5d0019ad-9b70-472e-b76e-254ee74959c6.png#averageHue=%23ebedeb&clientId=u4f4f76dc-c7be-4&from=paste&height=276&id=u0c412f8c&name=image.png&originHeight=644&originWidth=2168&originalType=binary&ratio=1&rotation=0&showTitle=false&size=460457&status=done&style=none&taskId=u832761b8-9e1f-4c6d-a621-6ff13fcac01&title=&width=929.2000122070312)
优点：

- 简单高效，若是针对单个 CPU 的情况，没有切换线程导致的开销
- 运行在 Client 模式下的虚拟机是个不错的选择

-XX:+UseSerialGC ：表明新生代使用 Serial GC，同时老年代使用 Serial Old GC
# ParNew 回收器：并行回收
如果说Serial GC是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本
Par：parallel          New：新生代
# Parallel Scavenge回收器：吞吐量优先

- 主要适合在后台运算而不需要太多交互的场景
# CMS （Concurrent-Mark-Sweep）回收器：低延迟
![image.png](https://cdn.nlark.com/yuque/0/2022/png/28316065/1667219899498-ee3e457a-395e-47f5-b3bd-c3bbe3381c6b.png#averageHue=%23e9eae9&clientId=u2b24b9cd-7ade-4&from=paste&height=263&id=uf3027be1&name=image.png&originHeight=263&originWidth=1062&originalType=binary&ratio=1&rotation=0&showTitle=false&size=130480&status=done&style=none&taskId=u5fd08195-f6db-48e1-98f0-53f7603764d&title=&width=1062)
## 初始标记
会有 STW，主要是标记出 GC Roots 能直接关联的对象，由于直接关联对象比较小，所以这里速度很快
## 并发标记
从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发执行
## 重新标记
修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
## 并发清除
由于在垃圾收集阶段用户线程没有中断，所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用，因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是当堆内存使用率达到某一阈值时，便开始进行回收，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行

- 如果 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，之后会启动后备预案，临时启用 Serial Old 收集器来重新进行老年代的垃圾回收，这样停顿时间就很长

优点：

- 并发收集
- 低延迟

缺点：

- **会产生内存碎片，因为采用的是标记-清除算法，导致并发清除之后，用户线程可用的空间不足，在无法分配大对象的情况下，不得不触发 Full GC**
- **CMS 收集器对 CPU 资源非常敏感，在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低**
- **CMS 无法处理浮动垃圾**

若设置老年代垃圾回收器为 CMS，则 JVM 会自动把新生代垃圾回收器设置为 ParNew
## 小结

- 如果你想要最小化地使用内存和并行开销，请选择 Serial GC
- 如果你想要最大化应用程序的吞吐量，请选择Parallel GC
- 如果你想要最小化 GC 的中断或停顿时间，请选择 CMS GC
# G1 回收器：区域化分块式
官方给定的目标：在延迟可控的情况下获得尽可能高的吞吐量

- G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region，物理上是不连续的），使用不同的 Region 来表示 Eden，幸存者 0 区，幸存者 1 区，老年代等。
- G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集，G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region
- 这种方式的侧重点在于回收垃圾最大量的区间
- 面向服务器应用的垃圾收集器，主要针对配备多核 CPU 及大容量内存的机器，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征
- JDK 9 之后默认的垃圾回收器
## 并行与并发

- 并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW
- 并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此一般来说，不会出现在整个回收阶段发生完全阻塞应用程序的情况
## 分代收集

- 从分代上来看，G1 依然属于分代型的垃圾回收器，所以他还是会分为年轻代和老年嗲，年轻代依然有 Eden 区和 Suvivor 区，但是从堆的结构上来看，它不要求整个堆是连续的
## 空间与整合

- Region 之间（Eden -> Suvivor）使用的是复制算法，但是整体上实际可以看作是标记-压缩算法，两种算法都可以避免碎片化，这种特性有利于程序长时间的运行
## 可预测的停顿时间模型

- G1 除了可以追求低停顿之外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒
   - 由于分区的原因，G1 可以只选择部分区域进行回收，这样就缩小了回收的范围
   - G1 跟踪各个 region 的价值，在后台会维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 region，保证了 G1 收集器在有限时间内可以获取尽可能高的收集效率
- 相比 CMS GC，可能 G1 上限没有 CMS 高，但是最差情况要好很多

相较于 CMS，G1并不具全全方位的压制优势，从经验上来看，在小内存应用上 CMS 的表现大概率会好于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6 - 8GB 之间
## 使用场景

- 主要是面对服务器端，针对具有大内存、多处理器的机器
- 最主要的应用场景是需要低 GC 延迟，并具有大堆的应用程序提供解决方案
- HotSpot 垃圾收集器中，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程
## 分区 Region：化整为零

- region 内部用的是 Bump-the-pointer
- region 内部也可以分配 TLAB
- G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，主要用于存储大对象，如果超过 1.5 个 region，就放到 H
   - 对于堆中的大对象，默认会放到老年代，但是如果它是一个短期存在的大对象，就会对垃圾收集器造成负面影响，为了解决这个问题，G1 划分了一个 Humongous 区，它专门用来存储大对象，如果一个 H 区都存放不下，那么 G1 会寻找连续的 H 区去存放
## 主要回收环节

- 年轻代（Young GC）
   - G1 的年轻代收集阶段是一个**并行**的**独占式**的收集器
- 老年代并发标记过程（Concurrent Marking）
   - 当堆空间的内存使用达到一定阈值的时候（45%），开始老年代并发标记过程
- 混合回收（Mixed GC）
   - G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了
- 如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的，它针对 GC 的评估失败提供了一种失败保护机制，即强力回收
### 记忆集 Remembered Set

- 一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，导致难道回收新生代还要遍历一遍老年代？
- 每个 Region 都有一个对应的 Remembered Set
- 每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作，然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region，如果不同，通过 CardTable 把相关的引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set中，当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set，就可以保证不进行全局扫描，也不会有遗漏
## 回收过程
### 年轻代 GC
当 Eden 区空间耗尽的时候，G1 会启动一次年轻代垃圾回收
年轻代垃圾回收只会回收 Eden 和 Survivor

1. 扫描根
   1. 根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等，跟引用联通 Rset 记录的外部引用作为扫描存活对象的入口
2. 更新 Rset
   1. 处理 dirty card queue 中的 card，更新 Rset，此阶段完成之后，Rset 可以准确的反应老年代对所在的内存分段中对象的引用
   2. 之所以不每次赋值的时候更新是因为更新 dcq 需要同步，为了性能考虑，队列效率更高
3. 处理 Rset
   1. 识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象
4. 复制对象
   1. 此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Surviovor 区中内存段中存活的对象如果年龄未达到阈值，年龄会 +1，达到阈值会被复制到 Old 区中空的内存分段，如果 Survivor 区中的内存空间不够，Eden 空间的部分数据会直接晋升到老年代空间
5. 处理引用
### 并发标记 - 主要针对老年代

1. 初始标记阶段
   1. 标记从根节点直接可达的对象，这个阶段是 STW 的，并且只会触发一次年轻代 GC
2. 根区域扫描
   1. G1 GC 扫描 Survivor 区可以直接可达的老年代的对象，并标记引用的对象，这一过程必须在 young GC 之前完成
3. 并发标记
4. 再次标记
5. 独占清理
6. 并发清理阶段
### 混合回收
## 设置建议

- 建议新生代的大小不要显示去设置，让 JVM 自己去调节
- 暂停时间目标不要太过严苛，会发生更高频的垃圾收集，会降低吞吐量

![image.png](https://cdn.nlark.com/yuque/0/2022/png/28316065/1667803227137-4be9a423-98e3-4a2b-af48-c93c22f48134.png#averageHue=%239fbca5&clientId=u2131dad6-5e1d-4&from=paste&height=268&id=u001a57a7&name=image.png&originHeight=295&originWidth=1183&originalType=binary&ratio=1&rotation=0&showTitle=false&size=493364&status=done&style=none&taskId=ub5adbfd8-995f-4db0-9341-b31dcab09a6&title=&width=1075.4545221446965)
# GC 日志分析
![image.png](https://cdn.nlark.com/yuque/0/2022/png/28316065/1667870166812-67b4a3da-7f7e-4a70-9890-fe852742ca3f.png#averageHue=%23dfe3de&clientId=u4b6d27ba-4203-4&from=paste&height=343&id=uda0f4986&name=image.png&originHeight=1030&originWidth=3092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1424305&status=done&style=none&taskId=u2c456212-2c8a-4928-b108-b28fde59345&title=&width=1030.6666666666667)
